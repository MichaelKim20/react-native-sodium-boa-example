import React, { Component } from 'react'
import {ScrollView, Text, View} from 'react-native'

import Base64 from 'base64-js'
import Sodium from 'react-native-sodium'

import {BasicTest} from './BasicTest'

export default class Test extends BasicTest {

  async _testCryptoBoxKeyPair() {
    let freq = [];
    for (i = 0; i < 256; ++i) freq[i] = 0;
    for (i = 0; i < 20*256/Sodium.crypto_sign_SECRETKEYBYTES; ++i) {
      let keyPair = await Sodium.crypto_box_keypair();
      let a = Base64.toByteArray(keyPair.sk)
      for (j = 0; j < a.length; ++j) ++freq[a[j]]
    }
    var fail = false
    for (i = 0; i < 256 && !fail; ++i) if (freq[i] == 0) fail = true
    this.testPassed('crypto_box_keypair',!fail)
  }


  _testCryptoBox1() {

    const testIteration = (mlen,alice,bob) =>
      Promise.all([
        Sodium.randombytes_buf(Sodium.crypto_box_NONCEBYTES),
        Sodium.randombytes_buf(mlen)
      ]).then(([n,m]) =>
        Sodium.crypto_box_easy(m,n,bob.pk,alice.sk)
          .then((c) => Sodium.crypto_box_open_easy(c,n,alice.pk,bob.sk))
          .then((mm) => mm === m)
      )

    const mlen_max = 1000

    Promise.all([Sodium.crypto_box_keypair(),Sodium.crypto_box_keypair()]).then(async ([alice,bob]) => {
      let isOk = true
      for (mlen = 0; mlen <= mlen_max; mlen++) {
        isOk = isOk && await testIteration(mlen,alice,bob)
      }
      this.testPassed('crypto_box_easy_1',isOk)
    }).catch((error) =>  this.testFailed('crypto_box_easy_1',error))
  }

  async _testCryptoBox2() {

    const small_order_p = Base64.fromByteArray(new Uint8Array([
      0xe0,0xeb,0x7a,0x7c,0x3b,0x41,0xb8,0xae,0x16,0x56,0xe3,0xfa,0xf1,0x9f,0xc4,0x6a,
      0xda,0x09,0x8d,0xeb,0x9c,0x32,0xb1,0xfd,0x86,0x62,0x05,0x16,0x5f,0x49,0xb8,0x00]))

    const alicepk = Base64.fromByteArray(new Uint8Array([
      0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a,
      0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]))

    const alicesk = Base64.fromByteArray(new Uint8Array([
      0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45,
      0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]))

    const bobpk = Base64.fromByteArray(new Uint8Array([
      0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37,
      0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]))

    const bobsk = Base64.fromByteArray(new Uint8Array([
      0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6,
      0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]))

    const nonce = Base64.fromByteArray(new Uint8Array([
      0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73,0xcd,0x62,0xbd,0xa8,
      0x75,0xfc,0x73,0xd6 ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37]))

    const m = Base64.fromByteArray(new Uint8Array([
      0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b,
      0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc,
      0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29,
      0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31,
      0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57,
      0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde,
      0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52,
      0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64,
      0x5e,0x07,0x05]))

    const c =  Base64.fromByteArray(new Uint8Array([
      0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9,
      0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
      0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
      0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
      0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
      0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
      0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
      0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
      0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
      0xe3,0x55,0xa5]))

      Sodium.crypto_box_easy(m,nonce,bobpk,alicesk).then((cc) => {
        this.testPassed('crypto_box_easy_2')
        Sodium.crypto_box_open_easy(cc,nonce,alicepk,bobsk)
          .then((mm) => this.testPassed('crypto_box_open_easy_2',c === cc && m === mm))
          .catch((error) =>  this.testFailed('crypto_box_open_easy_2',error))
      }).catch((error) => this.testFailed('crypto_box_easy_2',error))

      Sodium.crypto_box_beforenm(small_order_p, bobsk)
        .then(k1 => this.testFailed('crypto_box_beforenm (1)'))
        .catch(e => this.testPassed('crypto_box_beforenm (1)'))

      Sodium.crypto_box_beforenm(small_order_p, alicesk)
        .then(k1 => this.testFailed('crypto_box_beforenm (2)'))
        .catch(e => this.testPassed('crypto_box_beforenm (2)'))

      const [k1,k2] = await Sodium.crypto_box_beforenm(alicepk, bobsk)
        .then(k1 => Sodium.crypto_box_beforenm(bobpk, alicesk)
          .then(k2 => {this.testPassed('crypto_box_beforenm (3)'); return[k1,k2]}))
        .catch(e => {this.testFailed('crypto_box_beforenm (3)',e); return null})

      if (!!k1 && !!k2)
        Sodium.crypto_box_easy_afternm(m, nonce, k1)
          .then(c =>  Sodium.crypto_box_open_easy_afternm(c,nonce,k2))
          .then(m2 => this.testPassed('crypto_box_open_easy_afternm',m === m2))
          .catch(e => this.testFailed('crypto_box_open_easy_afternm',e))
  }

  _testSealBox()
  {
    Sodium.randombytes_uniform(1000).then(m_len =>
      Promise.all([Sodium.crypto_box_keypair(),Sodium.randombytes_buf(m_len)]).then(([{pk,sk},m]) => {
        Sodium.crypto_box_seal(m, pk)
          .then(c => Sodium.crypto_box_seal_open(c, pk, sk)
            .then(mm => this.testPassed('crypto_box_seal',m === mm))
          .catch(e => this.testFailed('crypto_box_seal',e)))
      })
    )
  }

  _testBoxConstants() {
    this.testPassed('crypto_box_SEEDBYTES', Sodium.crypto_box_SEEDBYTES > 0)
    this.testPassed('crypto_box_PUBLICKEYBYTES', Sodium.crypto_box_PUBLICKEYBYTES > 0)
    this.testPassed('crypto_box_SECRETKEYBYTES', Sodium.crypto_box_SECRETKEYBYTES > 0)
    this.testPassed('crypto_box_BEFORENMBYTES', Sodium.crypto_box_BEFORENMBYTES > 0)
    this.testPassed('crypto_box_NONCEBYTES', Sodium.crypto_box_NONCEBYTES > 0)
    this.testPassed('crypto_box_ZEROBYTES', Sodium.crypto_box_ZEROBYTES > 0)
    this.testPassed('crypto_box_BOXZEROBYTES', Sodium.crypto_box_BOXZEROBYTES > 0)
    this.testPassed('crypto_box_MACBYTES', Sodium.crypto_box_MACBYTES > 0)
    this.testPassed('crypto_box_SEALBYTES', Sodium.crypto_box_SEALBYTES > 0)
  }

  componentDidMount() {
    this.initTests([
      'crypto_box_keypair',
      'crypto_box_easy_1',
      'crypto_box_easy_2','crypto_box_open_easy_2',
      'crypto_box_beforenm (1)','crypto_box_beforenm (2)','crypto_box_beforenm (3)',
      'crypto_box_open_easy_afternm',
      'crypto_box_seal',
      'crypto_box_SEEDBYTES',
      'crypto_box_PUBLICKEYBYTES',
      'crypto_box_SECRETKEYBYTES',
      'crypto_box_BEFORENMBYTES',
      'crypto_box_NONCEBYTES',
      'crypto_box_ZEROBYTES',
      'crypto_box_BOXZEROBYTES',
      'crypto_box_MACBYTES',
      'crypto_box_SEALBYTES',
    ])

    // Public-key cryptography - authenticated encryption
    this._testCryptoBoxKeyPair()
    this._testCryptoBox1()
    this._testCryptoBox2()
    this._testSealBox()
    this._testBoxConstants()
  }

}
